# -*- coding: utf-8 -*-
"""goit-algo2-hw-04.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iNrproMDIpTAcE-U7dXwjrihwDw8BqrF

## Завдання 1. Розширення функціоналу префіксного дерева
"""

pip install trie

pip install TrieNode

class TrieNode:
    def __init__(self):
        self.children = {}
        self.value = None
        self.end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def put(self, key: str, value):
        node = self.root
        for char in key:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.end_of_word = True
        node.value = value

    def get_all_words(self):
        """Повертає всі слова, збережені в дереві"""
        result = []

        def dfs(node, path):
            if node.end_of_word:
                result.append(path)
            for char, child in node.children.items():
                dfs(child, path + char)

        dfs(self.root, "")
        return result


class Homework(Trie):
    # Функція для підрахунку кількості слів, що закінчуються заданим шаблоном
    def count_words_with_suffix(self, pattern) -> int:
        if not isinstance(pattern, str):
            raise ValueError("Суфікс має бути рядком.")

        words = self.get_all_words()
        return sum(1 for word in words if word.endswith(pattern))

    # Функція для перевірки наявності слів із заданим префіксом
    def has_prefix(self, prefix) -> bool:
        if not isinstance(prefix, str):
            raise ValueError("Префікс має бути рядком.")

        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True


if __name__ == "__main__":
    trie = Homework()
    words = ["apple", "application", "banana", "CAT", "battery", "demonstration"]
    for i, word in enumerate(words):
        trie.put(word, i)

    print(" Тестування count_words_with_suffix:")
    try:
        print("Суфікс 'e':", trie.count_words_with_suffix("e"))  # Очікується 0 (Apple закінчується на 'e', але з великої літери)
        print("Суфікс 'ion':", trie.count_words_with_suffix("ion"))  # Очікується 1
        print("Суфікс 'a':", trie.count_words_with_suffix("a"))  # Очікується 1
        print("Суфікс 'at':", trie.count_words_with_suffix("at"))  # Очікується 0 (бо 'CAT')
    except Exception as e:
        print("❌ Помилка:", e)

    print("\n Тестування has_prefix:")
    try:
        print("Префікс 'app':", trie.has_prefix("app"))  # True
        print("Префікс 'bat':", trie.has_prefix("bat"))  # True
        print("Префікс 'ban':", trie.has_prefix("ban"))  # True
        print("Префікс 'ca':", trie.has_prefix("ca"))  # False (бо 'CAT')
    except Exception as e:
        print("❌ Помилка:", e)

    print("\n Тестування обробки помилок:")
    try:
        trie.count_words_with_suffix(123)
    except Exception as e:
        print("count_words_with_suffix(123) →", e)

    try:
        trie.has_prefix(None)
    except Exception as e:
        print("has_prefix(None) →", e)

    print("\n✅ Усі тести виконано.")

"""##Завдання 2. Пошук найдовшого спільного префікса"""

class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def put(self, word: str):
        if not isinstance(word, str):
            raise TypeError("Слово повинно бути рядком.")
        node = self.root
        for char in word:
            node = node.children.setdefault(char, TrieNode())
        node.is_end_of_word = True

# Клас LongestCommonWord з успадкуванням класу Trie
class LongestCommonWord(Trie):
    # Метод find_longest_common_word
    def find_longest_common_word(self, strings) -> str:
        if not isinstance(strings, list) or not all(isinstance(s, str) for s in strings):
            raise ValueError("Вхідні дані мають бути списком рядків.")
        if not strings:
            return ""

        # Побудова Trie
        for word in strings:
            self.put(word)

        # Пошук префікса
        prefix = ""
        node = self.root
        while node:
            if len(node.children) == 1 and not node.is_end_of_word:
                char = next(iter(node.children))
                prefix += char
                node = node.children[char]
            else:
                break
        return prefix

if __name__ == "__main__":
    def run_tests():
        tests = [
            {
                "strings": ["flower", "flow", "flight"],
                "expected": "fl"
            },
            {
                "strings": ["interspecies", "interstellar", "interstate"],
                "expected": "inters"
            },
            {
                "strings": ["dog", "racecar", "car"],
                "expected": ""
            },
            {
                "strings": [],
                "expected": ""
            },
            {
                "strings": ["same", "same", "same"],
                "expected": "same"
            },
            {
                "strings": ["prefix"],
                "expected": "prefix"
            },
            {
                "strings": ["valid", 123, "input"],
                "expected_exception": ValueError
            }
        ]

        for i, test in enumerate(tests, 1):
            trie = LongestCommonWord()
            try:
                result = trie.find_longest_common_word(test["strings"])
                assert result == test["expected"], f"❌ Тест {i} не пройдено: очікувалося '{test['expected']}', отримано '{result}'"
                print(f"✅ Тест {i} пройдено: {result}")
            except Exception as e:
                print(f"❌ Тест {i} не пройдено через помилку: {e}")

    run_tests()